<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Docker实战（二十六）Docker的run命令使用 | birdben</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="上一篇介绍了Dockerfile的配置详情用法，这里具体在讲解一下Docker的run命令使用，之前在构建自己的Docker镜像时，很多参数都没有深入研究，只是保证Docker容器的正常使用，这里run命令可以动态设置一些启动Docker容器的参数。
Docker run命令格式最基本的docker run命令的格式如下：
1$ sudo docker run [OPTIONS] IMAGE[:T">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker实战（二十六）Docker的run命令使用">
<meta property="og:url" content="https://github.com/birdben/2017/02/07/Docker/Docker实战（二十六）Docker的run命令使用/index.html">
<meta property="og:site_name" content="birdben">
<meta property="og:description" content="上一篇介绍了Dockerfile的配置详情用法，这里具体在讲解一下Docker的run命令使用，之前在构建自己的Docker镜像时，很多参数都没有深入研究，只是保证Docker容器的正常使用，这里run命令可以动态设置一些启动Docker容器的参数。
Docker run命令格式最基本的docker run命令的格式如下：
1$ sudo docker run [OPTIONS] IMAGE[:T">
<meta property="og:updated_time" content="2017-05-07T10:48:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker实战（二十六）Docker的run命令使用">
<meta name="twitter:description" content="上一篇介绍了Dockerfile的配置详情用法，这里具体在讲解一下Docker的run命令使用，之前在构建自己的Docker镜像时，很多参数都没有深入研究，只是保证Docker容器的正常使用，这里run命令可以动态设置一些启动Docker容器的参数。
Docker run命令格式最基本的docker run命令的格式如下：
1$ sudo docker run [OPTIONS] IMAGE[:T">
  
    <link rel="alternative" href="/atom.xml" title="birdben" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script type="text/javascript">
var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260188951'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1260188951' type='text/javascript'%3E%3C/script%3E"));
</script>

</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/logo.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">birdben</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/birdben" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AWK/" style="font-size: 10.83px;">AWK</a> <a href="/tags/Akka/" style="font-size: 10.83px;">Akka</a> <a href="/tags/Dockerfile/" style="font-size: 20px;">Dockerfile</a> <a href="/tags/Docker命令/" style="font-size: 19.17px;">Docker命令</a> <a href="/tags/Docker环境/" style="font-size: 15px;">Docker环境</a> <a href="/tags/ELK/" style="font-size: 16.67px;">ELK</a> <a href="/tags/ElasticSearch/" style="font-size: 10.83px;">ElasticSearch</a> <a href="/tags/Elasticsearch/" style="font-size: 12.5px;">Elasticsearch</a> <a href="/tags/Flume/" style="font-size: 17.5px;">Flume</a> <a href="/tags/Git命令/" style="font-size: 13.33px;">Git命令</a> <a href="/tags/Go/" style="font-size: 14.17px;">Go</a> <a href="/tags/HBase/" style="font-size: 10px;">HBase</a> <a href="/tags/HDFS/" style="font-size: 18.33px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hadoop原理架构体系/" style="font-size: 13.33px;">Hadoop原理架构体系</a> <a href="/tags/Hive/" style="font-size: 16.67px;">Hive</a> <a href="/tags/JVM/" style="font-size: 11.67px;">JVM</a> <a href="/tags/Java-Web，Socket，Python/" style="font-size: 10px;">Java Web，Socket，Python</a> <a href="/tags/Jenkins环境/" style="font-size: 10px;">Jenkins环境</a> <a href="/tags/Kafka/" style="font-size: 15.83px;">Kafka</a> <a href="/tags/Kibana/" style="font-size: 14.17px;">Kibana</a> <a href="/tags/Linux命令/" style="font-size: 12.5px;">Linux命令</a> <a href="/tags/Logstash/" style="font-size: 15.83px;">Logstash</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/MapReduce/" style="font-size: 11.67px;">MapReduce</a> <a href="/tags/Maven配置/" style="font-size: 11.67px;">Maven配置</a> <a href="/tags/MongoDB/" style="font-size: 11.67px;">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Shadowsocks/" style="font-size: 10px;">Shadowsocks</a> <a href="/tags/Shell/" style="font-size: 16.67px;">Shell</a> <a href="/tags/Spring/" style="font-size: 10.83px;">Spring</a> <a href="/tags/Storm/" style="font-size: 12.5px;">Storm</a> <a href="/tags/Zookeeper/" style="font-size: 12.5px;">Zookeeper</a> <a href="/tags/其他/" style="font-size: 10px;">其他</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/birdben">我的CSDN的博客</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">birdben</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/logo.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">birdben</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/birdben" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Docker/Docker实战（二十六）Docker的run命令使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/07/Docker/Docker实战（二十六）Docker的run命令使用/" class="article-date">
  	<time datetime="2017-02-07T02:14:24.000Z" itemprop="datePublished">2017-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Docker实战（二十六）Docker的run命令使用
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dockerfile/">Dockerfile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker命令/">Docker命令</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Docker/">Docker</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇介绍了Dockerfile的配置详情用法，这里具体在讲解一下Docker的run命令使用，之前在构建自己的Docker镜像时，很多参数都没有深入研究，只是保证Docker容器的正常使用，这里run命令可以动态设置一些启动Docker容器的参数。</p>
<h3 id="Docker-run命令格式"><a href="#Docker-run命令格式" class="headerlink" title="Docker run命令格式"></a>Docker run命令格式</h3><p>最基本的docker run命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...]</div></pre></td></tr></table></figure>
<p>之前第一篇Docker文章介绍过Docker的基础命令，其中也说明了run命令的一些参数，这里我们在回顾一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 指定配置启动</div><div class="line">$ sudo docker run -d -p 10.211.55.4:9999:22 birdben/ubuntu:v1 &apos;/usr/sbin/sshd&apos; -D</div><div class="line"></div><div class="line"># 参数：</div><div class="line"># -d：表示以“守护模式”执行，日志不会出现在输出终端上(输出结果可以用docker logs 查看)。使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。</div><div class="line"># -i：表示以“交互模式”运行容器，-i 则让容器的标准输入保持打开</div><div class="line"># -t：表示容器启动后会进入其命令行，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</div><div class="line"># -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;，-v 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</div><div class="line"># -p：表示宿主机与容器的端口映射，此时将容器内部的 22 端口映射为宿主机的 9999 端口，这样就向外界暴露了 9999 端口，可通过 Docker 网桥来访问容器内部的 22 端口了。</div><div class="line"></div><div class="line"># 注意：</div><div class="line"># 这里使用的是宿主机的 IP 地址：10.211.55.4，与对外暴露的端口号 9999，它映射容器内部的端口号 22。ssh外部需要访问：ssh root@10.211.55.4 -p 9999</div><div class="line"># 容器是否会长久运行，是和docker run指定的命令有关，和 -d 参数无关。</div><div class="line"># run启动不一定要使用“镜像 ID”，也可以使用“仓库名:标签名”</div></pre></td></tr></table></figure>
<p>注意：</p>
<p>这里在说明一下自己的之前构建的镜像的问题，这里不推荐在Docker中安装SSH，通过SSH来远程登录到Docker容器，应该通过在宿主机运行docker exec的方式进入Docker容器来进行操作，这样安全性更好，这是自己之前构建Docker镜像存在的一些问题。</p>
<h3 id="容器识别"><a href="#容器识别" class="headerlink" title="容器识别"></a>容器识别</h3><h4 id="Name（–name）"><a href="#Name（–name）" class="headerlink" title="Name（–name）"></a>Name（–name）</h4><p>可以通过三种方式为容器命名：</p>
<ul>
<li>使用UUID长命名（”f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778”）</li>
<li>使用UUID短命令（”f78375b1c487”）</li>
<li>使用Name(“evil_ptolemy”)</li>
</ul>
<p>这个UUID标示是由Docker deamon生成的。如果你在执行docker run时没有指定–name，那么deamon会自动生成一个随机字符串UUID。但是对于一个容器来说有个name会非常方便，当你需要连接其它容器时或者类似需要区分其它容器时，使用容器名称可以简化操作。无论容器运行在前台或者后台，这个名字都是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name docker_shadowsocks birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<p>推荐运行Docker容器的时候指定一个容器名字，后续对于Docker容器的操作比较容易，否则每次使用Docker容器的ID操作都需要使用docker ps来查看比较麻烦。</p>
<h3 id="PID-equivalent"><a href="#PID-equivalent" class="headerlink" title="PID equivalent"></a>PID equivalent</h3><p>如果在使用Docker时有自动化的需求，你可以将containerID输出到指定的文件中（PIDfile），类似于某些应用程序将自身ID输出到文件中，方便后续脚本操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --cidfile=&quot;/var/run/docker_shadowsocks.pid&quot; --name docker_shadowsocks birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<h4 id="Image-tag"><a href="#Image-tag" class="headerlink" title="Image[:tag]"></a>Image[:tag]</h4><p>当一个镜像的名称不足以分辨这个镜像所代表的含义时，你可以通过tag将版本信息添加到run命令中，以执行特定版本的镜像。这个也是我之前比较常用的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<h4 id="Network-Settings"><a href="#Network-Settings" class="headerlink" title="Network Settings"></a>Network Settings</h4><p>默认情况下，所有的容器都开启了网络接口，同时可以接受任何外部的数据请求。这个是设置Docker网络配置的参数，如果你有多个Docker容器之前需要网络通信，那么这个参数是比较常用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--dns=[]         : Set custom dns servers for the container</div><div class="line">--net=&quot;bridge&quot;   : Set the Network mode for the container</div><div class="line">  &apos;bridge&apos;: creates a new network stack for the container on the docker bridge</div><div class="line">  &apos;none&apos;: no networking for this container</div><div class="line">  &apos;container:&lt;name|id&gt;&apos;: reuses another container network stack</div><div class="line">  &apos;host&apos;: use the host network stack inside the container</div><div class="line">--add-host=&quot;&quot;    : Add a line to /etc/hosts (host:IP)</div><div class="line">--mac-address=&quot;&quot; : Sets the container&apos;s Ethernet device&apos;s MAC address</div></pre></td></tr></table></figure>
<p>你可以通过docker run –net none来关闭网络接口，此时将关闭所有网络数据的输入输出，你只能通过STDIN、STDOUT或者files来完成I/O操作。默认情况下，容器使用主机的DNS设置，你也可以通过–dns来覆盖容器内的DNS设置。同时Docker为容器默认生成一个MAC地址，你可以通过–mac-address 12:34:56:78:9a:bc来设置你自己的MAC地址。</p>
<p>Docker支持的网络模式有：</p>
<ul>
<li>none : 关闭容器内的网络连接</li>
<li>bridge : 通过veth接口来连接容器，默认配置。</li>
<li>host : 允许容器使用host的网络堆栈信息。 注意：这种方式将允许容器访问host中类似D-BUS之类的系统服务，所以认为是不安全的。</li>
<li>container : 使用另外一个容器的网络堆栈信息。</li>
</ul>
<h4 id="管理-etc-hosts"><a href="#管理-etc-hosts" class="headerlink" title="管理/etc/hosts"></a>管理/etc/hosts</h4><p>/etc/hosts文件中会包含容器的hostname信息，我们也可以使用–add-host这个参数来动态添加/etc/hosts中的数据。使用–add-host参数我们就可以动态配置hosts，而不需要在构建镜像的时候将/etc/hosts文件写好并且覆盖到Docker镜像中，这个也是我之前所犯下的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /docker run -it --add-host mysql:192.168.2.108 birdben/shadowsocks:v1 cat /etc/hosts127.0.0.1	localhost192.168.2.109  hadoop1192.168.2.110  hadoop2192.168.2.111  hadoop3192.168.2.108  mysql</div></pre></td></tr></table></figure>
<h4 id="Clean-up-–rm"><a href="#Clean-up-–rm" class="headerlink" title="Clean up (–rm)"></a>Clean up (–rm)</h4><p>默认情况下，每个容器在退出时，它的文件系统也会保存下来，这样一方面调试会方便些，因为你可以通过查看日志等方式来确定最终状态。另外一方面，你也可以保存容器所产生的数据。但是当你仅仅需要短暂的运行一个容器，并且这些数据不需要保存，你可能就希望Docker能在容器结束时自动清理其所产生的数据。这个时候你就需要–rm这个参数了，–rm参数设置为true会在停止Docker容器的时候自动删除该容器的，在构建调试Docker容器的时候比较方便，省去手动反复删除Docker容器的操作，自己深有体会推荐构建调试的时候使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 。</div><div class="line"># 注意：--rm 和 -d不能共用！</div><div class="line">$ docker run -itd --rm=true -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div><div class="line">Conflicting options: --rm and -d</div><div class="line"></div><div class="line"># 正确用法，挂载到宿主机的日志文件是不会被删除的</div><div class="line">$ docker run -it --rm=true -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<h3 id="覆盖Dockerfile配置文件默认值"><a href="#覆盖Dockerfile配置文件默认值" class="headerlink" title="覆盖Dockerfile配置文件默认值"></a>覆盖Dockerfile配置文件默认值</h3><p>Docker run命令可以指定参数来覆盖Dockerfile中的配置，这些参数中，有四个是无法被覆盖的：FROM、MAINTAINER、RUN和ADD（这里可能是原作者写漏了，COPY也应该是无法被覆盖的），其余参数都可以通过docker run进行覆盖。我们将介绍如何对这些参数进行覆盖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CMD (Default Command or Options)</div><div class="line">ENTRYPOINT (Default Command to Execute at Runtime)</div><div class="line">EXPOSE (Incoming Ports)</div><div class="line">ENV (Environment Variables)</div><div class="line">VOLUME (Shared Filesystems)</div><div class="line">USER</div><div class="line">WORKDIR</div></pre></td></tr></table></figure>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...]</div></pre></td></tr></table></figure>
<p>这个命令中的COMMAND部分是可选的。因为这个IMAGE在build时，开发人员可能已经设定了默认执行的命令。作为操作人员，你可以使用上面命令中新的command来覆盖旧的command。</p>
<p>如果镜像中设定了ENTRYPOINT，那么命令中的CMD也可以作为参数追加到ENTRYPOINT中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 这里使用/bin/bash命令覆盖原来启动supervisor的命令，这里是直接进入Docker容器了，并且检查supervisor进程并没有启动</div><div class="line">$ docker run -it -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1 /bin/bash</div><div class="line">root@77d46c117967:/# ps -ef | grep supervisor</div><div class="line">root        16     1  0 03:54 ?        00:00:00 grep --color=auto supervisor</div></pre></td></tr></table></figure>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--entrypoint=&quot;&quot;: Overwrite the default entrypoint set by the image</div></pre></td></tr></table></figure>
<p>这个ENTRYPOINT和COMMAND类似，它指定了当容器执行时，需要启动哪些进程。相对COMMAND而言，ENTRYPOINT是很难进行覆盖的，这个ENTRYPOINT可以让容器设定默认启动行为，所以当容器启动时，你可以执行任何一个二进制可执行程序。你也可以通过COMMAND为ENTRYPOINT传递参数。但当你需要在容器中执行其它进程时，你就可以指定其它ENTRYPOINT了。</p>
<p>下面就是一个例子，容器可以在启动时自动执行Shell，然后启动其它进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -i -t --entrypoint /bin/bash example/redis</div><div class="line">#or two examples of how to pass more parameters to that ENTRYPOINT:</div><div class="line">$ sudo docker run -i -t --entrypoint /bin/bash example/redis -c ls -l</div><div class="line">$ sudo docker run -i -t --entrypoint /usr/bin/redis-cli example/redis --help</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 常见问题：&quot;docker-entrypoint.sh&quot;: executable file not found in $PATH.</div><div class="line"></div><div class="line"># 多数原因是因为docker-entrypoint.sh脚本文件没有执行权限，需要在Dockerfile修改脚本文件的执行权限，或者在宿主机修改挂载的docker-entrypoint.sh脚本文件的执行权限</div><div class="line"></div><div class="line">RUN chmod +x docker-entrypoint.sh</div></pre></td></tr></table></figure>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">--expose=[]: Expose a port or a range of ports from the container</div><div class="line">        without publishing it to your host</div><div class="line">-P=false   : Publish all exposed ports to the host interfaces</div><div class="line">-p=[]      : Publish a container᾿s port to the host (format:</div><div class="line">         ip:hostPort:containerPort | ip::containerPort |</div><div class="line">         hostPort:containerPort | containerPort)</div><div class="line">         (use &apos;docker port&apos; to see the actual mapping)</div><div class="line">--link=&quot;&quot;  : Add link to another container (name:alias)</div></pre></td></tr></table></figure>
<p>–expose可以让容器接受外部传入的数据。容器内监听的端口不需要和外部主机的端口相同。比如说在容器内部，一个HTTP服务监听在80端口，对应外部主机的端口就可能是49880.</p>
<p>如果使用-p或者-P，那么容器会开放部分端口到主机，只要对方可以连接到主机，就可以连接到容器内部。当使用-P时，Docker会在主机中随机从49153和65535之间查找一个未被占用的端口绑定到容器。你可以使用docker port来查找这个随机绑定端口。</p>
<p>当你使用–link方式时，作为客户端的容器可以通过私有网络形式访问到这个容器。同时Docker会在客户端的容器中设定一些环境变量来记录绑定的IP和PORT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 这里设置宿主机和Docker容器的端口都是443</div><div class="line">$ docker run -itd -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash</div></pre></td></tr></table></figure>
<p>这将在容器中设置简单（非数组）环境变量。 为了说明这里显示所有三个标志。 其中-e，-env取一个环境变量和值，或者如果没有提供”=”，那么通过export设置该变量的当前值（即，来自主机的$MYVAR1被设置为容器中的$MYVAR1） 。当没有提供”=”且该变量没有在客户端环境中定义时，那个变量将从容器的环境变量列表中删除。所有三个标志，-e，–env和–env文件可以重复。</p>
<p>不管这三个标志的顺序如何，首先处理–env文件，然后处理-e，-env标志。 这样，-e或–env将根据需要覆盖变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat ./env.list</div><div class="line">TEST_FOO=BAR</div><div class="line">$ docker run --env TEST_FOO=&quot;This is a test&quot; --env-file ./env.list busybox env | grep TEST_FOO</div><div class="line">TEST_FOO=This is a test</div></pre></td></tr></table></figure>
<p>–env-file标志采用文件名作为参数，并且期望每一行都处于VAR = VAL格式，模拟传递给–env的参数。 注释行只需要前缀为＃</p>
<p>使用–env-file传递的文件示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$ cat ./env.list</div><div class="line">TEST_FOO=BAR</div><div class="line"></div><div class="line"># this is a comment</div><div class="line">TEST_APP_DEST_HOST=10.10.0.127</div><div class="line">TEST_APP_DEST_PORT=8888</div><div class="line">_TEST_BAR=FOO</div><div class="line">TEST_APP_42=magic</div><div class="line">helloWorld=true</div><div class="line">123qwe=bar</div><div class="line">org.spring.config=something</div><div class="line"></div><div class="line"># pass through this variable from the caller</div><div class="line">TEST_PASSTHROUGH</div><div class="line">$ TEST_PASSTHROUGH=howdy docker run --env-file ./env.list busybox env</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</div><div class="line">HOSTNAME=5198e0745561</div><div class="line">TEST_FOO=BAR</div><div class="line">TEST_APP_DEST_HOST=10.10.0.127</div><div class="line">TEST_APP_DEST_PORT=8888</div><div class="line">_TEST_BAR=FOO</div><div class="line">TEST_APP_42=magic</div><div class="line">helloWorld=true</div><div class="line">TEST_PASSTHROUGH=howdy</div><div class="line">HOME=/root</div><div class="line">123qwe=bar</div><div class="line">org.spring.config=something</div><div class="line"></div><div class="line">$ docker run --env-file ./env.list busybox env</div><div class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</div><div class="line">HOSTNAME=5198e0745561</div><div class="line">TEST_FOO=BAR</div><div class="line">TEST_APP_DEST_HOST=10.10.0.127</div><div class="line">TEST_APP_DEST_PORT=8888</div><div class="line">_TEST_BAR=FOO</div><div class="line">TEST_APP_42=magic</div><div class="line">helloWorld=true</div><div class="line">TEST_PASSTHROUGH=</div><div class="line">HOME=/root</div><div class="line">123qwe=bar</div><div class="line">org.spring.config=something</div></pre></td></tr></table></figure>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>通过”-v”参数来覆盖挂载路径，这个是比较常用的，因为大多数日志或者数据文件都会挂载到宿主机目录的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-v=[]: Create a bind mount with: [host-dir]:[container-dir]:[rw|ro].</div><div class="line">   If &quot;container-dir&quot; is missing, then docker creates a new volume.</div><div class="line">--volumes-from=&quot;&quot;: Mount all volumes from the given container(s)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 宿主机目录：/Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks</div><div class="line"># Docker容器目录：/var/log/shadowsocks</div><div class="line">$ docker run -itd -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div></pre></td></tr></table></figure>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>容器中默认的用户是root，但是开发人员创建新的用户之后，这些新用户也是可以使用的。开发人员可以通过Dockerfile的USER设定默认的用户，并通过”-u”来覆盖这些参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 这里我通过-u参数指定的shadowsocks用户来运行，但是我并没有创建过shadowsocks用户，所以下面报错了</div><div class="line">$ docker run -it --rm=true -u=&quot;shadowsocks&quot; -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div><div class="line">docker: Error response from daemon: linux spec user: unable to find user shadowsocks: no matching entries in passwd file.</div></pre></td></tr></table></figure>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>容器中默认的工作目录是根目录（/）。开发人员可以通过Dockerfile的WORKDIR来设定默认工作目录，操作人员可以通过”-w”来覆盖默认的工作目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># -w指定默认工作目录是&quot;/usr/local&quot;</div><div class="line">$ docker run -itd -w=&quot;/usr/local&quot; -p 443:443 -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/shadowsocks:/var/log/shadowsocks -v /Users/yunyu/workspace_git/birdDocker/shadowsocks/logs/supervisor:/var/log/supervisor --name shadowsocks_docker birdben/shadowsocks:v1</div><div class="line">358618f9aa4d1c388b3dc9c7e5c6236bb9b6b150728e474710e83f0409dd6007</div><div class="line"></div><div class="line">$ docker exec -it 358618f9aa4d /bin/bash</div><div class="line">root@358618f9aa4d:/usr/local#</div></pre></td></tr></table></figure>
<p>这里我只记录了自己使用Docker常用的配置，更多详细配置用法请看参考文章，谢谢!</p>
<p>参考文章：</p>
<ul>
<li><a href="http://dockone.io/article/152" target="_blank" rel="external">http://dockone.io/article/152</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank" rel="external">https://docs.docker.com/engine/reference/commandline/run/</a></li>
<li><a href="https://github.com/docker/docker/issues/27182">https://github.com/docker/docker/issues/27182</a></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/07/Logstash/Logstash学习（七）Logstash的webhdfs插件/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Logstash学习（七）Logstash的webhdfs插件
        
      </div>
    </a>
  
  
    <a href="/2017/02/06/Docker/Docker实战（二十五）Dockerfile文件配置/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Docker实战（二十五）Dockerfile文件配置</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>








</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 birdben
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-82900755-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>